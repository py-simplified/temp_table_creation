CREATE OR REPLACE PROCEDURE `cohesive-apogee-411113.My_Results.build_temp_targets`(config_fqn STRING, selected_targets ARRAY<STRING>)
BEGIN
  -- 1) Stage valid config rows
  EXECUTE IMMEDIATE FORMAT("""
    CREATE TEMP TABLE tmp_cfg AS
    SELECT *
    FROM `%s`
    WHERE Target_Table      IS NOT NULL
      AND Target_Column     IS NOT NULL
      AND Derivation_Logic  IS NOT NULL
  """, config_fqn);

  -- 2) Iterate targets
  FOR t IN (
    SELECT DISTINCT Target_Project_Id, Target_Dataset_Id, Target_Table
    FROM tmp_cfg
    WHERE ARRAY_LENGTH(selected_targets) = 0
       OR Target_Table IN UNNEST(selected_targets)
    ORDER BY Target_Project_Id, Target_Dataset_Id, Target_Table
  ) DO
    BEGIN
      -- Declarations (must be at top)
      DECLARE src_p STRING;
      DECLARE src_d STRING;
      DECLARE src_t STRING;
      DECLARE src_count INT64;
      DECLARE dup_cols INT64;
      DECLARE join_clauses STRING DEFAULT '';
      DECLARE select_list STRING;
      DECLARE ref_pattern STRING;          -- dynamic alternation: e.g. "reference_mapping|reference_mapping_01"
      DECLARE has_refs BOOL;

      -- 3) Get single source triple
      SET (src_p, src_d, src_t) = (
        SELECT AS STRUCT
          ANY_VALUE(Source_Project_Id),
          ANY_VALUE(Source_Dataset_Id),
          ANY_VALUE(Source_Table)
        FROM tmp_cfg
        WHERE Target_Project_Id = t.Target_Project_Id
          AND Target_Dataset_Id = t.Target_Dataset_Id
          AND Target_Table      = t.Target_Table
      );

      -- 4) Validate exactly one source
      SET src_count = (
        SELECT COUNT(DISTINCT TO_JSON_STRING(STRUCT(Source_Project_Id, Source_Dataset_Id, Source_Table)))
        FROM tmp_cfg
        WHERE Target_Project_Id = t.Target_Project_Id
          AND Target_Dataset_Id = t.Target_Dataset_Id
          AND Target_Table      = t.Target_Table
      );
      ASSERT src_count = 1 AS 'Each target must map to exactly one source table (Project/Dataset/Table).';

      -- 5) No duplicate target columns
      SET dup_cols = (
        SELECT COUNT(*)
        FROM (
          SELECT Target_Column
          FROM tmp_cfg
          WHERE Target_Project_Id = t.Target_Project_Id
            AND Target_Dataset_Id = t.Target_Dataset_Id
            AND Target_Table      = t.Target_Table
          GROUP BY Target_Column
          HAVING COUNT(*) > 1
        )
      );
      ASSERT dup_cols = 0 AS 'Duplicate Target_Column entries found for this target.';

      -- 6) Build dynamic reference table pattern (escaped, OR-joined), and join clauses
      SET ref_pattern = (
        SELECT STRING_AGG(
                 -- Escape any regex metacharacters in table names, just in case
                 REGEXP_REPLACE(Reference_Table, r'([.^$|()\[\]\\+*?{}-])', r'\\\1'),
                 '|'
               )
        FROM (
          SELECT DISTINCT Reference_Table
          FROM tmp_cfg
          WHERE Target_Project_Id = t.Target_Project_Id
            AND Target_Dataset_Id = t.Target_Dataset_Id
            AND Target_Table      = t.Target_Table
            AND Reference_Table IS NOT NULL
            AND LOWER(Reference_Table) != 'nan'
        )
      );

      SET has_refs = (ref_pattern IS NOT NULL AND LENGTH(ref_pattern) > 0);

      IF has_refs THEN
        -- First, create a temp table with unique aliases for reference tables
        CREATE OR REPLACE TEMP TABLE ref_aliases AS (
          SELECT 
            Reference_Table,
            Reference_Join_Key, 
            Reference_Lookup_Column,
            CASE 
              WHEN ROW_NUMBER() OVER (PARTITION BY Reference_Table ORDER BY Reference_Join_Key, Reference_Lookup_Column) = 1 
              THEN Reference_Table
              ELSE CONCAT(Reference_Table, '_', CAST(ROW_NUMBER() OVER (PARTITION BY Reference_Table ORDER BY Reference_Join_Key, Reference_Lookup_Column) AS STRING))
            END AS alias_name
          FROM (
            SELECT DISTINCT Reference_Table, Reference_Join_Key, Reference_Lookup_Column
            FROM tmp_cfg
            WHERE Target_Project_Id = t.Target_Project_Id
              AND Target_Dataset_Id = t.Target_Dataset_Id
              AND Target_Table      = t.Target_Table
              AND Reference_Table IS NOT NULL
              AND LOWER(Reference_Table) != 'nan'
              AND Reference_Join_Key IS NOT NULL
              AND Reference_Lookup_Column IS NOT NULL
          )
        );

        -- Build one LEFT JOIN per distinct combination using the pre-computed aliases
        SET join_clauses = (
          SELECT STRING_AGG(
                   FORMAT(
                     'LEFT JOIN `%s.%s.%s` AS `%s` ON `%s`.`%s` = `%s`.`%s`',
                     src_p, src_d, Reference_Table, 
                     alias_name,
                     src_t, Reference_Lookup_Column,
                     alias_name, 
                     Reference_Join_Key
                   ),
                   '\n'
                 )
          FROM ref_aliases
        );
      END IF;

      -- 7) Build SELECT list, row-by-row fixups:
      --    If a row has a Reference_Table, rewrite any leading reference-table prefix
      --    (or generic 'ref.') to that specific Reference_Table with correct unique alias.
      SET select_list = (
        SELECT STRING_AGG(
                 FORMAT('%s AS `%s`',
                   CASE
                     WHEN cfg.Reference_Table IS NOT NULL AND LOWER(cfg.Reference_Table) != 'nan' THEN
                       -- Get the correct alias for this specific reference combination and apply it
                       REGEXP_REPLACE(
                         REGEXP_REPLACE(cfg.Derivation_Logic,
                                        r'\bref\.', CONCAT(COALESCE(ra.alias_name, cfg.Reference_Table), '.')),
                         CONCAT('\\b', cfg.Reference_Table, '\\.'),
                         CONCAT(COALESCE(ra.alias_name, cfg.Reference_Table), '.')
                       )
                     ELSE
                       cfg.Derivation_Logic
                   END,
                   cfg.Target_Column
                 ),
                 ',\n  ' ORDER BY cfg.Scenario_ID, cfg.Target_Column
               )
        FROM tmp_cfg cfg
        LEFT JOIN ref_aliases ra ON cfg.Reference_Table = ra.Reference_Table 
                                  AND cfg.Reference_Join_Key = ra.Reference_Join_Key
                                  AND cfg.Reference_Lookup_Column = ra.Reference_Lookup_Column
        WHERE cfg.Target_Project_Id = t.Target_Project_Id
          AND cfg.Target_Dataset_Id = t.Target_Dataset_Id
          AND cfg.Target_Table      = t.Target_Table
      );
      ASSERT select_list IS NOT NULL AND LENGTH(select_list) > 0 AS 'No columns to select for this target.';

      -- 8) Execute CTAS
      EXECUTE IMMEDIATE FORMAT("""
      CREATE OR REPLACE TABLE `%s.%s.%s_%s_Temp` AS
      SELECT
        %s
      FROM `%s.%s.%s` AS `%s`
      %s
    """,
      t.Target_Project_Id, t.Target_Dataset_Id, t.Target_Table, src_d,  -- add src_d here
      select_list,
      src_p, src_d, src_t,
      src_t,
      IFNULL(join_clauses, '')
    );
    END;
  END FOR;
END;
